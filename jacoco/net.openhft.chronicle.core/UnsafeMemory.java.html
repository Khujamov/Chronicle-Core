<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>UnsafeMemory.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">OpenHFT/Chronicle-Core</a> &gt; <a href="index.source.html" class="el_package">net.openhft.chronicle.core</a> &gt; <span class="el_source">UnsafeMemory.java</span></div><h1>UnsafeMemory.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2016-2020 chronicle.software
 *
 * https://chronicle.software
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package net.openhft.chronicle.core;

import net.openhft.chronicle.core.annotation.ForceInline;
import org.jetbrains.annotations.NotNull;
import sun.misc.Unsafe;

import java.lang.reflect.Field;
import java.nio.BufferOverflowException;
import java.nio.BufferUnderflowException;
import java.util.concurrent.atomic.AtomicLong;

@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L31">public class UnsafeMemory implements Memory {</span>

    @NotNull
    public static final Unsafe UNSAFE;
    public static final UnsafeMemory INSTANCE;
    public static final boolean tracing = false;
    // see java.nio.Bits.copyMemory
    // This number limits the number of bytes to copy per call to Unsafe's
    // copyMemory method. A limit is imposed to allow for safepoint polling
    // during a large copy
    static final long UNSAFE_COPY_THRESHOLD = 1024L * 1024L;

    static {
        try {
<span class="fc" id="L45">            Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</span>
<span class="fc" id="L46">            theUnsafe.setAccessible(true);</span>
<span class="fc" id="L47">            UNSAFE = (Unsafe) theUnsafe.get(null);</span>
<span class="nc" id="L48">        } catch (@NotNull NoSuchFieldException | IllegalAccessException | IllegalArgumentException e) {</span>
<span class="nc" id="L49">            throw new AssertionError(e);</span>
<span class="fc" id="L50">        }</span>
<span class="pc bpc" id="L51" title="1 of 2 branches missed.">        INSTANCE = Jvm.isArm() ? new ARMMemory() : new UnsafeMemory();</span>
<span class="fc" id="L52">    }</span>

<span class="fc" id="L54">    private final AtomicLong nativeMemoryUsed = new AtomicLong();</span>

    private static int retryReadVolatileInt(long address, int value) {
<span class="nc" id="L57">        int value2 = UNSAFE.getIntVolatile(null, address);</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">        while (value2 != value) {</span>
<span class="nc bnc" id="L59" title="All 4 branches missed.">            if (value != 0 &amp;&amp; value != 0x80000000)</span>
<span class="nc" id="L60">                Jvm.warn().on(UnsafeMemory.class, &quot;Int@&quot; + Long.toHexString(address) + &quot; (&quot; + (address &amp; 63) + &quot;) &quot; +</span>
<span class="nc" id="L61">                        &quot;was &quot; + Integer.toHexString(value) +</span>
<span class="nc" id="L62">                        &quot; is now &quot; + Integer.toHexString(value2));</span>
<span class="nc" id="L63">            value = value2;</span>
<span class="nc" id="L64">            value2 = UNSAFE.getIntVolatile(null, address);</span>
        }
<span class="nc" id="L66">        return value;</span>
    }

    private static long retryReadVolatileLong(long address, long value) {
<span class="nc" id="L70">        long value2 = UNSAFE.getLongVolatile(null, address);</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">        while (value2 != value) {</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">            if (value != 0)</span>
<span class="nc" id="L73">                Jvm.warn().on(UnsafeMemory.class, &quot;please add padding() when using concurrent writers, &quot; +</span>
                        &quot;Long@&quot; +
<span class="nc" id="L75">                        Long.toHexString(address) + &quot; (&quot; + (address &amp; 63) + &quot;) &quot; +</span>
<span class="nc" id="L76">                        &quot;was &quot; + Long.toHexString(value) +</span>
<span class="nc" id="L77">                        &quot; is now &quot; + Long.toHexString(value2));</span>
<span class="nc" id="L78">            value = value2;</span>
<span class="nc" id="L79">            value2 = UNSAFE.getLongVolatile(null, address);</span>
        }
<span class="nc" id="L81">        return value;</span>
    }

    public static void putInt(byte[] bytes, int offset, int value) {
<span class="nc" id="L85">        UnsafeMemory.UNSAFE.putInt(bytes,</span>
                (long) Unsafe.ARRAY_BYTE_BASE_OFFSET + offset,
                value);
<span class="nc" id="L88">    }</span>

    public static void unsafeStoreFence() {
<span class="nc" id="L91">        UNSAFE.storeFence();</span>
<span class="nc" id="L92">    }</span>

    public static void unsafeLoadFence() {
<span class="nc" id="L95">        UNSAFE.loadFence();</span>
<span class="nc" id="L96">    }</span>

    public static long unsafeGetLong(long address) {
<span class="nc" id="L99">        return UNSAFE.getLong(address);</span>
    }

    public static int unsafeGetInt(long address) {
<span class="nc" id="L103">        return UNSAFE.getInt(address);</span>
    }

    public static byte unsafeGetByte(long address) {
<span class="nc" id="L107">        return UNSAFE.getByte(address);</span>
    }

    public static void unsafePutLong(long address, long value) {
<span class="nc" id="L111">        UNSAFE.putLong(address, value);</span>
<span class="nc" id="L112">    }</span>

    public static void unsafePutInt(long address, int value) {
<span class="nc" id="L115">        UNSAFE.putInt(address, value);</span>
<span class="nc" id="L116">    }</span>

    public static void unsafePutByte(long address, byte value) {
<span class="nc" id="L119">        UNSAFE.putByte(address, value);</span>
<span class="nc" id="L120">    }</span>

    public static void unsafePutLong(byte[] bytes, int offset, long value) {
<span class="nc" id="L123">        UNSAFE.putLong(bytes, (long) Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, value);</span>
<span class="nc" id="L124">    }</span>

    public static void unsafePutInt(byte[] bytes, int offset, int value) {
<span class="nc" id="L127">        UNSAFE.putInt(bytes, (long) Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, value);</span>
<span class="nc" id="L128">    }</span>

    public static void unsafePutByte(byte[] bytes, int offset, byte value) {
<span class="nc" id="L131">        UNSAFE.putByte(bytes, (long) Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, value);</span>
<span class="nc" id="L132">    }</span>

    public static void copyMemory(long from, long to, int length)
            throws BufferUnderflowException, BufferOverflowException {
<span class="nc" id="L136">        long i = 0;</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">        for (; i &lt; length - 7; i += 8) {</span>
<span class="nc" id="L138">            unsafePutLong(to, unsafeGetLong(from));</span>
<span class="nc" id="L139">            from += 8;</span>
<span class="nc" id="L140">            to += 8;</span>
        }
<span class="nc bnc" id="L142" title="All 2 branches missed.">        for (; i &lt; length; i++)</span>
<span class="nc" id="L143">            unsafePutByte(to++, unsafeGetByte(from++));</span>
<span class="nc" id="L144">    }</span>

    public static void unsafePutBoolean(Object obj, long offset, boolean value) {
<span class="nc" id="L147">        UNSAFE.putBoolean(obj, offset, value);</span>
<span class="nc" id="L148">    }</span>

    public static boolean unsafeGetBoolean(Object obj, long offset) {
<span class="nc" id="L151">        return UNSAFE.getBoolean(obj, offset);</span>
    }

    public static void unsafePutByte(Object obj, long offset, byte value) {
<span class="nc" id="L155">        UNSAFE.putByte(obj, offset, value);</span>
<span class="nc" id="L156">    }</span>

    public static byte unsafeGetByte(Object obj, long offset) {
<span class="nc" id="L159">        return UNSAFE.getByte(obj, offset);</span>
    }

    public static void unsafePutChar(Object obj, long offset, char value) {
<span class="nc" id="L163">        UNSAFE.putChar(obj, offset, value);</span>
<span class="nc" id="L164">    }</span>

    public static char unsafeGetChar(Object obj, long offset) {
<span class="nc" id="L167">        return UNSAFE.getChar(obj, offset);</span>
    }

    public static void unsafePutShort(Object obj, long offset, short value) {
<span class="nc" id="L171">        UNSAFE.putShort(obj, offset, value);</span>
<span class="nc" id="L172">    }</span>

    public static short unsafeGetShort(Object obj, long offset) {
<span class="nc" id="L175">        return UNSAFE.getShort(obj, offset);</span>
    }

    public static void unsafePutInt(Object obj, long offset, int value) {
<span class="nc" id="L179">        UNSAFE.putInt(obj, offset, value);</span>
<span class="nc" id="L180">    }</span>

    public static int unsafeGetInt(Object obj, long offset) {
<span class="nc" id="L183">        return UNSAFE.getInt(obj, offset);</span>
    }

    public static void unsafePutFloat(Object obj, long offset, float value) {
<span class="nc" id="L187">        UNSAFE.putFloat(obj, offset, value);</span>
<span class="nc" id="L188">    }</span>

    public static float unsafeGetFloat(Object obj, long offset) {
<span class="nc" id="L191">        return UNSAFE.getFloat(obj, offset);</span>
    }

    public static void unsafePutLong(Object obj, long offset, long value) {
<span class="nc" id="L195">        UNSAFE.putLong(obj, offset, value);</span>
<span class="nc" id="L196">    }</span>

    public static long unsafeGetLong(Object obj, long offset) {
<span class="nc" id="L199">        return UNSAFE.getLong(obj, offset);</span>
    }

    public static void unsafePutDouble(Object obj, long offset, double value) {
<span class="nc" id="L203">        UNSAFE.putDouble(obj, offset, value);</span>
<span class="nc" id="L204">    }</span>

    public static double unsafeGetDouble(Object obj, long offset) {
<span class="nc" id="L207">        return UNSAFE.getDouble(obj, offset);</span>
    }

    public static void unsafePutObject(Object obj, long offset, Object value) {
<span class="nc" id="L211">        UNSAFE.putObject(obj, offset, value);</span>
<span class="nc" id="L212">    }</span>

    public static &lt;T&gt; T unsafeGetObject(Object obj, long offset) {
<span class="nc" id="L215">        return (T) UNSAFE.getObject(obj, offset);</span>
    }

    public static long unsafeObjectFieldOffset(Field field) {
<span class="nc" id="L219">        return UNSAFE.objectFieldOffset(field);</span>
    }

    @NotNull
    @Override
    public &lt;E&gt; E allocateInstance(Class&lt;? extends E&gt; clazz) throws InstantiationException {
        @NotNull
<span class="fc" id="L226">        E e = (E) UNSAFE.allocateInstance(clazz);</span>
<span class="fc" id="L227">        return e;</span>
    }

    @Override
    public long getFieldOffset(Field field) {
<span class="fc" id="L232">        return UNSAFE.objectFieldOffset(field);</span>
    }

    @Override
    public void setInt(@NotNull Object object, long offset, int value) {
<span class="nc bnc" id="L237" title="All 2 branches missed.">        if (object == null)</span>
<span class="nc" id="L238">            throw new NullPointerException();</span>
<span class="nc" id="L239">        UNSAFE.putInt(object, offset, value);</span>
<span class="nc" id="L240">    }</span>

    @NotNull
    @Override
    public &lt;T&gt; T getObject(@NotNull Object object, long offset) {
<span class="pc bpc" id="L245" title="1 of 2 branches missed.">        if (object == null)</span>
<span class="nc" id="L246">            throw new NullPointerException();</span>
<span class="fc" id="L247">        return (T) UNSAFE.getObject(object, offset);</span>
    }

    @Override
    @ForceInline
    public void storeFence() {
<span class="nc" id="L253">        UNSAFE.storeFence();</span>
<span class="nc" id="L254">    }</span>

    @Override
    @ForceInline
    public void loadFence() {
<span class="nc" id="L259">        UNSAFE.loadFence();</span>
<span class="nc" id="L260">    }</span>

    @Override
    @ForceInline
    public void setMemory(long address, long size, byte b) {
<span class="nc" id="L265">        UNSAFE.setMemory(address, size, b);</span>
<span class="nc" id="L266">    }</span>

    @Override
    public void freeMemory(long address, long size) {
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">        if (address != 0)</span>
<span class="fc" id="L271">            UNSAFE.freeMemory(address);</span>
<span class="fc" id="L272">        nativeMemoryUsed.addAndGet(-size);</span>
<span class="fc" id="L273">    }</span>

    @Override
    public long allocate(long capacity) throws IllegalArgumentException {
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">        if (capacity &lt;= 0)</span>
<span class="nc" id="L278">            throw new IllegalArgumentException(&quot;Invalid capacity: &quot; + capacity);</span>
<span class="fc" id="L279">        long address = UNSAFE.allocateMemory(capacity);</span>
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">        if (address == 0)</span>
<span class="nc" id="L281">            throw new OutOfMemoryError(&quot;Not enough free native memory, capacity attempted: &quot; + capacity / 1024 + &quot; KiB&quot;);</span>

<span class="fc" id="L283">        nativeMemoryUsed.addAndGet(capacity);</span>

<span class="fc" id="L285">        return address;</span>
    }

    @Override
    public long nativeMemoryUsed() {
<span class="nc" id="L290">        return nativeMemoryUsed.get();</span>
    }

    @Override
    @ForceInline
    public void writeByte(long address, byte b) {
<span class="nc" id="L296">        UNSAFE.putByte(address, b);</span>
<span class="nc" id="L297">    }</span>

    @Override
    @ForceInline
    public void writeByte(@NotNull Object object, long offset, byte b) {
<span class="nc bnc" id="L302" title="All 2 branches missed.">        if (object == null)</span>
<span class="nc" id="L303">            throw new NullPointerException();</span>
<span class="nc" id="L304">        UNSAFE.putByte(object, offset, b);</span>
<span class="nc" id="L305">    }</span>

    @Override
    @ForceInline
    public byte readByte(@NotNull Object object, long offset) {
<span class="nc bnc" id="L310" title="All 2 branches missed.">        if (object == null)</span>
<span class="nc" id="L311">            throw new NullPointerException();</span>
<span class="nc" id="L312">        return UNSAFE.getByte(object, offset);</span>
    }

    @Override
    @ForceInline
    public void writeBytes(long address, byte[] b, int offset, int length) {
<span class="nc bnc" id="L318" title="All 2 branches missed.">        if (offset + length &gt; b.length)</span>
<span class="nc" id="L319">            throw new IllegalArgumentException(&quot;Invalid offset or length, array's length is &quot; + b.length);</span>
<span class="nc" id="L320">        UnsafeMemory.UNSAFE.copyMemory(b, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, null, address, length);</span>
<span class="nc" id="L321">    }</span>

    @Override
    @ForceInline
    public void readBytes(long address, byte[] b, long offset, int length) {
<span class="nc bnc" id="L326" title="All 2 branches missed.">        if (offset + length &gt; b.length)</span>
<span class="nc" id="L327">            throw new IllegalArgumentException(&quot;Invalid offset or length, array's length is &quot; + b.length);</span>
<span class="nc" id="L328">        UnsafeMemory.UNSAFE.copyMemory(null, address, b, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, length);</span>
<span class="nc" id="L329">    }</span>

    @Override
    @ForceInline
    public byte readByte(long address) {
        if (tracing)
            System.out.println(&quot;Read &quot; + Long.toHexString(address));
<span class="nc" id="L336">        return UNSAFE.getByte(address);</span>
    }

    @Override
    @ForceInline
    public void writeShort(long address, short i16) {
<span class="fc" id="L342">        UNSAFE.putShort(address, i16);</span>
<span class="fc" id="L343">    }</span>

    @Override
    @ForceInline
    public void writeShort(@NotNull Object object, long offset, short i16) {
<span class="nc bnc" id="L348" title="All 2 branches missed.">        if (object == null)</span>
<span class="nc" id="L349">            throw new NullPointerException();</span>
<span class="nc" id="L350">        UNSAFE.putShort(object, offset, i16);</span>
<span class="nc" id="L351">    }</span>

    @Override
    @ForceInline
    public short readShort(long address) {
<span class="fc" id="L356">        return UNSAFE.getShort(address);</span>
    }

    @Override
    @ForceInline
    public short readShort(@NotNull Object object, long offset) {
<span class="nc bnc" id="L362" title="All 2 branches missed.">        if (object == null)</span>
<span class="nc" id="L363">            throw new NullPointerException();</span>
<span class="nc" id="L364">        return UNSAFE.getShort(object, offset);</span>
    }

    @Override
    @ForceInline
    public void writeInt(long address, int i32) {
<span class="fc" id="L370">        UNSAFE.putInt(address, i32);</span>
<span class="fc" id="L371">    }</span>

    @Override
    @ForceInline
    public void writeInt(@NotNull Object object, long offset, int i32) {
<span class="nc bnc" id="L376" title="All 2 branches missed.">        if (object == null)</span>
<span class="nc" id="L377">            throw new NullPointerException();</span>
<span class="nc" id="L378">        UNSAFE.putInt(object, offset, i32);</span>
<span class="nc" id="L379">    }</span>

    @Override
    @ForceInline
    public void writeOrderedInt(long address, int i32) {
//        assert (address &amp; 0x3) == 0;
<span class="fc" id="L385">        UNSAFE.putOrderedInt(null, address, i32);</span>
<span class="fc" id="L386">    }</span>

    @Override
    @ForceInline
    public void writeOrderedInt(@NotNull Object object, long offset, int i32) {
<span class="nc bnc" id="L391" title="All 2 branches missed.">        if (object == null)</span>
<span class="nc" id="L392">            throw new NullPointerException();</span>
<span class="nc" id="L393">        UNSAFE.putOrderedInt(object, offset, i32);</span>
<span class="nc" id="L394">    }</span>

    @Override
    @ForceInline
    public int readInt(long address) {
        if (tracing)
            System.out.println(&quot;Read int &quot; + Long.toHexString(address));
<span class="fc" id="L401">        return UNSAFE.getInt(address);</span>
    }

    @Override
    @ForceInline
    public int readInt(Object object, long offset) {
<span class="nc bnc" id="L407" title="All 2 branches missed.">        if (object != null) {</span>
<span class="nc" id="L408">            return UNSAFE.getInt(object, offset);</span>
        }
<span class="nc" id="L410">        throw new NullPointerException();</span>
    }

    @Override
    @ForceInline
    public void writeLong(long address, long i64) {
<span class="fc" id="L416">        UNSAFE.putLong(address, i64);</span>
<span class="fc" id="L417">    }</span>

    @Override
    @ForceInline
    public void writeLong(Object object, long offset, long i64) {
<span class="nc bnc" id="L422" title="All 2 branches missed.">        if (object != null) {</span>
<span class="nc" id="L423">            UNSAFE.putLong(object, offset, i64);</span>
        } else {
<span class="nc" id="L425">            throw new NullPointerException();</span>
        }
<span class="nc" id="L427">    }</span>

    @Override
    @ForceInline
    public long readLong(long address) {
        if (tracing)
            System.out.println(&quot;Read long &quot; + Long.toHexString(address));
<span class="fc" id="L434">        return UNSAFE.getLong(address);</span>
    }

    @Override
    @ForceInline
    public long readLong(Object object, long offset) {
<span class="nc bnc" id="L440" title="All 2 branches missed.">        if (object != null)</span>
<span class="nc" id="L441">            return UNSAFE.getLong(object, offset);</span>
<span class="nc" id="L442">        throw new NullPointerException();</span>
    }

    @Override
    @ForceInline
    public void writeFloat(long address, float f) {
<span class="fc" id="L448">        UNSAFE.putFloat(address, f);</span>
<span class="fc" id="L449">    }</span>

    @Override
    @ForceInline
    public void writeFloat(Object object, long offset, float f) {
<span class="nc bnc" id="L454" title="All 2 branches missed.">        if (object != null) {</span>
<span class="nc" id="L455">            UNSAFE.putFloat(object, offset, f);</span>
        } else {
<span class="nc" id="L457">            throw new NullPointerException();</span>
        }
<span class="nc" id="L459">    }</span>

    @Override
    @ForceInline
    public float readFloat(long address) {
<span class="fc" id="L464">        return UNSAFE.getFloat(address);</span>
    }

    @Override
    @ForceInline
    public float readFloat(Object object, long offset) {
<span class="nc bnc" id="L470" title="All 2 branches missed.">        if (object != null) {</span>
<span class="nc" id="L471">            return UNSAFE.getFloat(object, offset);</span>
        }
<span class="nc" id="L473">        throw new NullPointerException();</span>
    }

    @Override
    @ForceInline
    public void writeDouble(long address, double d) {
<span class="fc" id="L479">        UNSAFE.putDouble(address, d);</span>
<span class="fc" id="L480">    }</span>

    @Override
    @ForceInline
    public void writeDouble(Object object, long offset, double d) {
<span class="nc bnc" id="L485" title="All 2 branches missed.">        if (object != null) {</span>
<span class="nc" id="L486">            UNSAFE.putDouble(object, offset, d);</span>
        } else {
<span class="nc" id="L488">            throw new NullPointerException();</span>
        }
<span class="nc" id="L490">    }</span>

    @Override
    @ForceInline
    public double readDouble(long address) {
<span class="fc" id="L495">        return UNSAFE.getDouble(address);</span>
    }

    @Override
    @ForceInline
    public double readDouble(Object object, long offset) {
<span class="nc bnc" id="L501" title="All 2 branches missed.">        if (object != null) {</span>
<span class="nc" id="L502">            return UNSAFE.getDouble(object, offset);</span>
        }
<span class="nc" id="L504">        throw new NullPointerException();</span>
    }

    @Override
    @ForceInline
    public void copyMemory(byte[] bytes, int offset, long address, int length) {
<span class="nc" id="L510">        copyMemory(bytes, offset, null, address, length);</span>
<span class="nc" id="L511">    }</span>

    @Override
    @ForceInline
    public void copyMemory(long fromAddress, long address, long length) {
<span class="nc bnc" id="L516" title="All 2 branches missed.">        if (length &lt; UNSAFE_COPY_THRESHOLD) {</span>
<span class="nc" id="L517">            UNSAFE.copyMemory(null, fromAddress, null, address, length);</span>

        } else {
<span class="nc" id="L520">            copyMemory0(null, fromAddress, null, address, length);</span>
        }
<span class="nc" id="L522">    }</span>

    @Override
    @ForceInline
    public void copyMemory(byte[] bytes, int offset, Object obj2, long offset2, int length) {
<span class="nc bnc" id="L527" title="All 2 branches missed.">        if (length &lt; UNSAFE_COPY_THRESHOLD) {</span>
<span class="nc" id="L528">            UNSAFE.copyMemory(bytes, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, obj2, offset2, length);</span>

        } else {
<span class="nc" id="L531">            copyMemory0(bytes, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, obj2, offset2, length);</span>
        }
<span class="nc" id="L533">    }</span>

    @Override
    @ForceInline
    public void copyMemory(long fromAddress, Object obj2, long offset2, int length) {
<span class="nc bnc" id="L538" title="All 2 branches missed.">        long start = length &gt; 128 &lt;&lt; 10 ? System.nanoTime() : 0;</span>
<span class="nc" id="L539">        copyMemory0(null, fromAddress, obj2, offset2, length);</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">        if (length &gt; 128 &lt;&lt; 10) {</span>
<span class="nc" id="L541">            long time = System.nanoTime() - start;</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">            if (time &gt; 100_000)</span>
<span class="nc" id="L543">                Jvm.warn().on(getClass(), &quot;Took &quot; + time / 1000 / 1e3 + &quot; ms to copy &quot; + length / 1024 + &quot; KB&quot;);</span>
        }
<span class="nc" id="L545">    }</span>

    void copyMemory0(Object from, long fromOffset, Object to, long toOffset, long length) {
        // use a loop to ensure there is a safe point every so often.
<span class="nc bnc" id="L549" title="All 2 branches missed.">        while (length &gt; 0) {</span>
<span class="nc" id="L550">            long size = Math.min(length, UNSAFE_COPY_THRESHOLD);</span>
<span class="nc" id="L551">            UNSAFE.copyMemory(from, fromOffset, to, toOffset, size);</span>
<span class="nc" id="L552">            length -= size;</span>
<span class="nc" id="L553">            fromOffset += size;</span>
<span class="nc" id="L554">            toOffset += size;</span>
<span class="nc" id="L555">        }</span>
<span class="nc" id="L556">    }</span>

    @Override
    @ForceInline
    public void writeOrderedLong(long address, long i) {
//        assert (address &amp; 0x7) == 0;
<span class="fc" id="L562">        UNSAFE.putOrderedLong(null, address, i);</span>
<span class="fc" id="L563">    }</span>

    @Override
    @ForceInline
    public void writeOrderedLong(Object object, long offset, long i) {
<span class="nc bnc" id="L568" title="All 2 branches missed.">        if (object != null) {</span>
<span class="nc" id="L569">            UNSAFE.putOrderedLong(object, offset, i);</span>
        } else {
<span class="nc" id="L571">            throw new NullPointerException();</span>
        }
<span class="nc" id="L573">    }</span>

    @Override
    public void testAndSetInt(long address, long offset, int expected, int value) throws IllegalStateException {
<span class="nc bnc" id="L577" title="All 2 branches missed.">        if (UNSAFE.compareAndSwapInt(null, address, expected, value))</span>
<span class="nc" id="L578">            return;</span>
<span class="nc" id="L579">        int actual = UNSAFE.getIntVolatile(null, address);</span>
<span class="nc" id="L580">        throw new IllegalStateException(&quot;Cannot change at &quot; + offset + &quot; expected &quot; + expected + &quot; was &quot; + actual);</span>
    }

    @Override
    public void testAndSetInt(Object object, long offset, int expected, int value) throws IllegalStateException {
<span class="nc bnc" id="L585" title="All 2 branches missed.">        if (UNSAFE.compareAndSwapInt(object, offset, expected, value))</span>
<span class="nc" id="L586">            return;</span>
<span class="nc" id="L587">        int actual = UNSAFE.getIntVolatile(object, offset);</span>
<span class="nc" id="L588">        throw new IllegalStateException(&quot;Cannot change &quot; + object.getClass().getSimpleName() + &quot; at &quot; + offset + &quot; expected &quot; + expected + &quot; was &quot; + actual);</span>
    }

    @Override
    @ForceInline
    public boolean compareAndSwapInt(long address, int expected, int value) {
//        assert (address &amp; 0x3) == 0;
<span class="fc" id="L595">        return UNSAFE.compareAndSwapInt(null, address, expected, value);</span>
    }

    @Override
    @ForceInline
    public boolean compareAndSwapInt(Object object, long offset, int expected, int value) {
<span class="nc bnc" id="L601" title="All 2 branches missed.">        if (object != null) {</span>
<span class="nc" id="L602">            return UNSAFE.compareAndSwapInt(object, offset, expected, value);</span>
        }
<span class="nc" id="L604">        throw new NullPointerException();</span>
    }

    @Override
    @ForceInline
    public boolean compareAndSwapLong(long address, long expected, long value) {
//        assert (address &amp; 0x7) == 0;
<span class="fc" id="L611">        return UNSAFE.compareAndSwapLong(null, address, expected, value);</span>
    }

    @Override
    @ForceInline
    public boolean compareAndSwapLong(Object object, long offset, long expected, long value) {
<span class="nc bnc" id="L617" title="All 2 branches missed.">        if (object != null) {</span>
<span class="nc" id="L618">            return UNSAFE.compareAndSwapLong(object, offset, expected, value);</span>
        }
<span class="nc" id="L620">        throw new NullPointerException();</span>
    }

    @Override
    public int pageSize() {
<span class="fc" id="L625">        return UNSAFE.pageSize();</span>
    }

    @Override
    @ForceInline
    public byte readVolatileByte(long address) {
<span class="fc" id="L631">        return UNSAFE.getByteVolatile(null, address);</span>
    }

    @Override
    @ForceInline
    public byte readVolatileByte(Object object, long offset) {
<span class="nc bnc" id="L637" title="All 2 branches missed.">        if (object != null) {</span>
<span class="nc" id="L638">            return UNSAFE.getByteVolatile(object, offset);</span>
        }
<span class="nc" id="L640">        throw new NullPointerException();</span>
    }

    @Override
    @ForceInline
    public short readVolatileShort(long address) {
        // TODO add support for a short split across cache lines.
<span class="fc" id="L647">        return UNSAFE.getShortVolatile(null, address);</span>
    }

    @Override
    @ForceInline
    public short readVolatileShort(Object object, long offset) {
<span class="nc bnc" id="L653" title="All 2 branches missed.">        if (object != null) {</span>
<span class="nc" id="L654">            return UNSAFE.getShortVolatile(object, offset);</span>
        }
<span class="nc" id="L656">        throw new NullPointerException();</span>
    }

    @Override
    @ForceInline
    public int readVolatileInt(long address) {
<span class="fc" id="L662">        int value = UNSAFE.getIntVolatile(null, address);</span>
<span class="pc bpc" id="L663" title="1 of 2 branches missed.">        if ((address &amp; 63) &lt;= 60) {</span>
<span class="pc bpc" id="L664" title="1 of 2 branches missed.">            if (value == 0)</span>
<span class="fc" id="L665">                value = UNSAFE.getIntVolatile(null, address);</span>
<span class="fc" id="L666">            return value;</span>
        }
<span class="nc" id="L668">        return retryReadVolatileInt(address, value);</span>
    }

    @Override
    @ForceInline
    public int readVolatileInt(Object object, long offset) {
<span class="nc bnc" id="L674" title="All 2 branches missed.">        if (object == null) {</span>
<span class="nc" id="L675">            throw new NullPointerException();</span>
        }
<span class="nc" id="L677">        return UNSAFE.getIntVolatile(object, offset);</span>
    }

    @Override
    @ForceInline
    public float readVolatileFloat(long address) {
        // TODO add support for a float split across cache lines.
<span class="fc" id="L684">        return UNSAFE.getFloatVolatile(null, address);</span>
    }

    @Override
    @ForceInline
    public float readVolatileFloat(Object object, long offset) {
<span class="nc bnc" id="L690" title="All 2 branches missed.">        if (object != null) {</span>
<span class="nc" id="L691">            return UNSAFE.getFloatVolatile(object, offset);</span>
        }
<span class="nc" id="L693">        throw new NullPointerException();</span>
    }

    @Override
    @ForceInline
    public long readVolatileLong(long address) {
<span class="fc" id="L699">        long value = UNSAFE.getLongVolatile(null, address);</span>
<span class="pc bpc" id="L700" title="1 of 2 branches missed.">        if ((address &amp; 63) &lt;= 64 - 8) {</span>
<span class="fc" id="L701">            return value;</span>
        }
<span class="nc" id="L703">        return retryReadVolatileLong(address, value);</span>
    }

    @Override
    @ForceInline
    public long readVolatileLong(Object object, long offset) {
<span class="nc bnc" id="L709" title="All 2 branches missed.">        if (object != null) {</span>
<span class="nc" id="L710">            return UNSAFE.getLongVolatile(object, offset);</span>
        }
<span class="nc" id="L712">        throw new NullPointerException();</span>
    }

    @Override
    @ForceInline
    public double readVolatileDouble(long address) {
        // TODO add support for a double split across cache lines.
<span class="fc" id="L719">        return UNSAFE.getDoubleVolatile(null, address);</span>
    }

    @Override
    @ForceInline
    public double readVolatileDouble(Object object, long offset) {
<span class="nc bnc" id="L725" title="All 2 branches missed.">        if (object != null) {</span>
<span class="nc" id="L726">            return UNSAFE.getDoubleVolatile(object, offset);</span>
        }
<span class="nc" id="L728">        throw new NullPointerException();</span>
    }

    @Override
    @ForceInline
    public void writeVolatileByte(long address, byte b) {
<span class="fc" id="L734">        UNSAFE.putByteVolatile(null, address, b);</span>
<span class="fc" id="L735">    }</span>

    @Override
    @ForceInline
    public void writeVolatileByte(Object object, long offset, byte b) {
<span class="nc bnc" id="L740" title="All 2 branches missed.">        if (object != null) {</span>
<span class="nc" id="L741">            UNSAFE.putByteVolatile(object, offset, b);</span>
        } else {
<span class="nc" id="L743">            throw new NullPointerException();</span>
        }
<span class="nc" id="L745">    }</span>

    @Override
    @ForceInline
    public void writeVolatileShort(long address, short i16) {
<span class="fc" id="L750">        UNSAFE.putShortVolatile(null, address, i16);</span>
<span class="fc" id="L751">    }</span>

    @Override
    @ForceInline
    public void writeVolatileShort(Object object, long offset, short i16) {
<span class="nc bnc" id="L756" title="All 2 branches missed.">        if (object == null)</span>
<span class="nc" id="L757">            throw new NullPointerException();</span>
<span class="nc" id="L758">        UNSAFE.putShortVolatile(object, offset, i16);</span>
<span class="nc" id="L759">    }</span>

    @Override
    @ForceInline
    public void writeVolatileInt(long address, int i32) {
//        assert (address &amp; 0x3) == 0;
<span class="fc" id="L765">        UNSAFE.putIntVolatile(null, address, i32);</span>
<span class="fc" id="L766">    }</span>

    @Override
    @ForceInline
    public void writeVolatileInt(Object object, long offset, int i32) {
<span class="nc bnc" id="L771" title="All 2 branches missed.">        if (object != null) {</span>
<span class="nc" id="L772">            UNSAFE.putIntVolatile(object, offset, i32);</span>
        } else {
<span class="nc" id="L774">            throw new NullPointerException();</span>
        }
<span class="nc" id="L776">    }</span>

    @Override
    @ForceInline
    public void writeVolatileFloat(long address, float f) {
//        assert (address &amp; 0x3) == 0;
<span class="fc" id="L782">        UNSAFE.putFloatVolatile(null, address, f);</span>
<span class="fc" id="L783">    }</span>

    @Override
    @ForceInline
    public void writeVolatileFloat(Object object, long offset, float f) {
<span class="nc bnc" id="L788" title="All 2 branches missed.">        if (object != null) {</span>
<span class="nc" id="L789">            UNSAFE.putFloatVolatile(object, offset, f);</span>
        } else {
<span class="nc" id="L791">            throw new NullPointerException();</span>
        }
<span class="nc" id="L793">    }</span>

    @Override
    @ForceInline
    public void writeVolatileLong(long address, long i64) {
//        assert (address &amp; 0x7) == 0;
<span class="fc" id="L799">        UNSAFE.putLongVolatile(null, address, i64);</span>
<span class="fc" id="L800">    }</span>

    @Override
    @ForceInline
    public void writeVolatileLong(Object object, long offset, long i64) {
<span class="nc bnc" id="L805" title="All 2 branches missed.">        if (object != null) {</span>
<span class="nc" id="L806">            UNSAFE.putLongVolatile(object, offset, i64);</span>
        } else {
<span class="nc" id="L808">            throw new NullPointerException();</span>
        }
<span class="nc" id="L810">    }</span>

    @Override
    @ForceInline
    public void writeVolatileDouble(long address, double d) {
//        assert (address &amp; 0x7) == 0;

<span class="fc" id="L817">        UNSAFE.putDoubleVolatile(null, address, d);</span>
<span class="fc" id="L818">    }</span>

    @Override
    @ForceInline
    public void writeVolatileDouble(Object object, long offset, double d) {
<span class="nc bnc" id="L823" title="All 2 branches missed.">        if (object != null) {</span>
<span class="nc" id="L824">            UNSAFE.putDoubleVolatile(object, offset, d);</span>
        } else {
<span class="nc" id="L826">            throw new NullPointerException();</span>
        }
<span class="nc" id="L828">    }</span>

    @Override
    @ForceInline
    public int addInt(long address, int increment) {
//        assert (address &amp; 0x3) == 0;
<span class="fc" id="L834">        return UNSAFE.getAndAddInt(null, address, increment) + increment;</span>
    }

    @Override
    @ForceInline
    public int addInt(Object object, long offset, int increment) {
//        assert (offset &amp; 0x3) == 0;
<span class="nc bnc" id="L841" title="All 2 branches missed.">        if (object != null) {</span>
<span class="nc" id="L842">            return UNSAFE.getAndAddInt(object, offset, increment) + increment;</span>
        }
<span class="nc" id="L844">        throw new NullPointerException();</span>
    }

    @Override
    @ForceInline
    public long addLong(long address, long increment) {
//        assert (address &amp; 0x7) == 0;
<span class="fc" id="L851">        return UNSAFE.getAndAddLong(null, address, increment) + increment;</span>
    }

    @Override
    @ForceInline
    public long addLong(Object object, long offset, long increment) {
//        assert (offset &amp; 0x7) == 0;
<span class="nc bnc" id="L858" title="All 2 branches missed.">        if (object != null) {</span>
<span class="nc" id="L859">            return UNSAFE.getAndAddLong(object, offset, increment) + increment;</span>
        }
<span class="nc" id="L861">        throw new NullPointerException();</span>
    }

    // https://github.com/OpenHFT/OpenHFT/issues/23
<span class="nc" id="L865">    static class ARMMemory extends UnsafeMemory {</span>
        @Override
        public short readVolatileShort(long address) {
<span class="nc bnc" id="L868" title="All 2 branches missed.">            if ((address &amp; 0x1) == 0)</span>
<span class="nc" id="L869">                return super.readVolatileShort(address);</span>
<span class="nc" id="L870">            UNSAFE.loadFence();</span>
<span class="nc" id="L871">            return super.readShort(address);</span>
        }

        @Override
        public void writeVolatileShort(long address, short i16) {
<span class="nc bnc" id="L876" title="All 2 branches missed.">            if ((address &amp; 0x1) == 0) {</span>
<span class="nc" id="L877">                super.writeVolatileShort(address, i16);</span>
            } else {
<span class="nc" id="L879">                super.writeShort(address, i16);</span>
<span class="nc" id="L880">                UNSAFE.storeFence();</span>
            }
<span class="nc" id="L882">        }</span>

        @Override
        public void writeFloat(long address, float f) {
<span class="nc bnc" id="L886" title="All 2 branches missed.">            if ((address &amp; 0x3) == 0)</span>
<span class="nc" id="L887">                super.writeFloat(address, f);</span>
            else
<span class="nc" id="L889">                super.writeInt(address, Float.floatToRawIntBits(f));</span>
<span class="nc" id="L890">        }</span>

        @Override
        public float readFloat(long address) {
<span class="nc bnc" id="L894" title="All 2 branches missed.">            if ((address &amp; 0x3) == 0)</span>
<span class="nc" id="L895">                return super.readFloat(address);</span>
<span class="nc" id="L896">            return Float.intBitsToFloat(super.readInt(address));</span>
        }

        @Override
        public void writeFloat(@NotNull Object object, long offset, float f) {
<span class="nc bnc" id="L901" title="All 2 branches missed.">            if ((offset &amp; 0x3) == 0)</span>
<span class="nc" id="L902">                super.writeFloat(object, offset, f);</span>
            else
<span class="nc" id="L904">                super.writeInt(object, offset, Float.floatToRawIntBits(f));</span>

<span class="nc" id="L906">        }</span>

        @Override
        public float readFloat(@NotNull Object object, long offset) {
<span class="nc bnc" id="L910" title="All 2 branches missed.">            if ((offset &amp; 0x3) == 0)</span>
<span class="nc" id="L911">                return super.readFloat(object, offset);</span>
<span class="nc" id="L912">            return Float.intBitsToFloat(super.readInt(object, offset));</span>
        }

        @Override
        public int readVolatileInt(long address) {
<span class="nc bnc" id="L917" title="All 2 branches missed.">            if ((address &amp; 0x3) == 0)</span>
<span class="nc" id="L918">                return super.readVolatileInt(address);</span>
<span class="nc" id="L919">            UNSAFE.loadFence();</span>
<span class="nc" id="L920">            return super.readInt(address);</span>
        }

        @Override
        public float readVolatileFloat(long address) {
<span class="nc bnc" id="L925" title="All 2 branches missed.">            if ((address &amp; 0x3) == 0)</span>
<span class="nc" id="L926">                return super.readVolatileFloat(address);</span>
<span class="nc" id="L927">            UNSAFE.loadFence();</span>
<span class="nc" id="L928">            return readFloat(address);</span>
        }

        @Override
        public void writeVolatileInt(long address, int i32) {
<span class="nc bnc" id="L933" title="All 2 branches missed.">            if ((address &amp; 0x3) == 0) {</span>
<span class="nc" id="L934">                super.writeVolatileInt(address, i32);</span>
            } else {
<span class="nc" id="L936">                writeInt(address, i32);</span>
<span class="nc" id="L937">                UNSAFE.storeFence();</span>
            }
<span class="nc" id="L939">        }</span>

        @Override
        public void writeOrderedInt(long address, int i32) {
<span class="nc bnc" id="L943" title="All 2 branches missed.">            if ((address &amp; 0x3) == 0)</span>
<span class="nc" id="L944">                super.writeOrderedInt(address, i32);</span>
            else
<span class="nc" id="L946">                writeVolatileInt(address, i32);</span>
<span class="nc" id="L947">        }</span>

        @Override
        public void writeOrderedInt(@NotNull Object object, long offset, int i32) {
<span class="nc bnc" id="L951" title="All 2 branches missed.">            if ((offset &amp; 0x3) == 0)</span>
<span class="nc" id="L952">                super.writeOrderedInt(object, offset, i32);</span>
            else
<span class="nc" id="L954">                super.writeVolatileInt(object, offset, i32);</span>
<span class="nc" id="L955">        }</span>

        @Override
        public void writeVolatileFloat(long address, float f) {
<span class="nc bnc" id="L959" title="All 2 branches missed.">            if ((address &amp; 0x3) == 0)</span>
<span class="nc" id="L960">                super.writeVolatileFloat(address, f);</span>
            else
<span class="nc" id="L962">                writeVolatileInt(address, Float.floatToRawIntBits(f));</span>
<span class="nc" id="L963">        }</span>

        @Override
        public int addInt(long address, int increment) {
<span class="nc bnc" id="L967" title="All 2 branches missed.">            if ((address &amp; 0x3) == 0)</span>
<span class="nc" id="L968">                return super.addInt(address, increment);</span>
<span class="nc" id="L969">            throw new IllegalArgumentException(&quot;mis-aligned&quot;);</span>
        }

        @Override
        public boolean compareAndSwapInt(long address, int expected, int value) {
<span class="nc bnc" id="L974" title="All 2 branches missed.">            if ((address &amp; 0x3) == 0)</span>
<span class="nc" id="L975">                return super.compareAndSwapInt(address, expected, value);</span>
<span class="nc" id="L976">            throw new IllegalArgumentException(&quot;mis-aligned&quot;);</span>
        }

        @Override
        public boolean compareAndSwapInt(@NotNull Object object, long offset, int expected, int value) {
<span class="nc bnc" id="L981" title="All 2 branches missed.">            if ((offset &amp; 0x3) == 0)</span>
<span class="nc" id="L982">                return super.compareAndSwapInt(object, offset, expected, value);</span>
<span class="nc" id="L983">            throw new IllegalArgumentException(&quot;mis-aligned&quot;);</span>
        }

        @Override
        public void testAndSetInt(long address, long offset, int expected, int value) throws IllegalStateException {
<span class="nc bnc" id="L988" title="All 2 branches missed.">            if ((address &amp; ~0x3) == 0) {</span>
<span class="nc bnc" id="L989" title="All 2 branches missed.">                if (UNSAFE.compareAndSwapInt(null, address, expected, value)) {</span>
<span class="nc" id="L990">                    return;</span>
                }
<span class="nc" id="L992">                int actual = UNSAFE.getIntVolatile(null, address);</span>
<span class="nc" id="L993">                throw new IllegalStateException(&quot;Cannot change at &quot; + offset + &quot; expected &quot; + expected + &quot; was &quot; + actual);</span>
            } else {
<span class="nc" id="L995">                UNSAFE.loadFence();</span>
<span class="nc" id="L996">                int actual = UNSAFE.getInt(address);</span>
<span class="nc bnc" id="L997" title="All 2 branches missed.">                if (actual == expected) {</span>
<span class="nc" id="L998">                    UNSAFE.putInt(address, value);</span>
<span class="nc" id="L999">                    UNSAFE.storeFence();</span>
<span class="nc" id="L1000">                    return;</span>
                }
<span class="nc" id="L1002">                throw new IllegalStateException(&quot;Cannot perform thread safe operation at &quot; + offset + &quot; as mis-aligned&quot;);</span>
            }
        }

        @Override
        public void testAndSetInt(Object object, long offset, int expected, int value) throws IllegalStateException {
<span class="nc bnc" id="L1008" title="All 2 branches missed.">            if ((offset &amp; ~0x3) == 0) {</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">                if (UNSAFE.compareAndSwapInt(object, offset, expected, value)) {</span>
<span class="nc" id="L1010">                    return;</span>
                }
<span class="nc" id="L1012">                int actual = UNSAFE.getIntVolatile(object, offset);</span>
<span class="nc" id="L1013">                throw new IllegalStateException(&quot;Cannot change &quot; + object.getClass().getSimpleName() + &quot; at &quot; + offset + &quot; expected &quot; + expected + &quot; was &quot; + actual);</span>
            } else {
<span class="nc" id="L1015">                UNSAFE.loadFence();</span>
<span class="nc" id="L1016">                int actual = UNSAFE.getInt(object, offset);</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">                if (actual == expected) {</span>
<span class="nc" id="L1018">                    UNSAFE.putInt(object, offset, value);</span>
<span class="nc" id="L1019">                    UNSAFE.storeFence();</span>
<span class="nc" id="L1020">                    return;</span>
                }
<span class="nc" id="L1022">                throw new IllegalStateException(&quot;Cannot perform thread safe operation on &quot; + object.getClass().getSimpleName() + &quot; at &quot; + offset + &quot; as mis-aligned&quot;);</span>
            }
        }

        @Override
        public void writeDouble(long address, double d) {
<span class="nc bnc" id="L1028" title="All 2 branches missed.">            if ((address &amp; 0x7) == 0)</span>
<span class="nc" id="L1029">                super.writeDouble(address, d);</span>
            else
<span class="nc" id="L1031">                super.writeLong(address, Double.doubleToRawLongBits(d));</span>
<span class="nc" id="L1032">        }</span>

        @Override
        public double readDouble(long address) {
<span class="nc bnc" id="L1036" title="All 2 branches missed.">            if ((address &amp; 0x7) == 0)</span>
<span class="nc" id="L1037">                return super.readDouble(address);</span>
<span class="nc" id="L1038">            return Double.longBitsToDouble(super.readLong(address));</span>
        }

        @Override
        public void writeDouble(@NotNull Object object, long offset, double d) {
<span class="nc bnc" id="L1043" title="All 2 branches missed.">            if ((offset &amp; 0x7) == 0) super.writeDouble(object, offset, d);</span>
            else
<span class="nc" id="L1045">                super.writeLong(object, offset, Double.doubleToRawLongBits(d));</span>
<span class="nc" id="L1046">        }</span>

        @Override
        public double readDouble(@NotNull Object object, long offset) {
<span class="nc bnc" id="L1050" title="All 2 branches missed.">            if ((offset &amp; 0x7) == 0) return super.readDouble(object, offset);</span>
<span class="nc" id="L1051">            return Double.longBitsToDouble(super.readLong(object, offset));</span>
        }

        @Override
        public void writeOrderedLong(long address, long i) {
<span class="nc bnc" id="L1056" title="All 2 branches missed.">            if ((address &amp; 0x7) == 0)</span>
<span class="nc" id="L1057">                super.writeOrderedLong(address, i);</span>
            else
<span class="nc" id="L1059">                writeVolatileLong(address, i);</span>
<span class="nc" id="L1060">        }</span>

        @Override
        public long readVolatileLong(long address) {
<span class="nc bnc" id="L1064" title="All 2 branches missed.">            if ((address &amp; 0x7) == 0)</span>
<span class="nc" id="L1065">                return super.readVolatileLong(address);</span>
<span class="nc" id="L1066">            UNSAFE.loadFence();</span>
<span class="nc" id="L1067">            return readLong(address);</span>
        }

        @Override
        public void writeOrderedLong(@NotNull Object object, long offset, long i) {
<span class="nc bnc" id="L1072" title="All 2 branches missed.">            if ((offset &amp; 0x7) == 0)</span>
<span class="nc" id="L1073">                super.writeOrderedLong(object, offset, i);</span>
            else
<span class="nc" id="L1075">                writeVolatileLong(object, offset, i);</span>
<span class="nc" id="L1076">        }</span>

        @Override
        public long readVolatileLong(@NotNull Object object, long offset) {
<span class="nc bnc" id="L1080" title="All 2 branches missed.">            if ((offset &amp; 0x7) == 0) return super.readVolatileLong(object, offset);</span>
<span class="nc" id="L1081">            UNSAFE.loadFence();</span>
<span class="nc" id="L1082">            return readLong(object, offset);</span>
        }

        @Override
        public double readVolatileDouble(long address) {
<span class="nc bnc" id="L1087" title="All 2 branches missed.">            if ((address &amp; 0x7) == 0)</span>
<span class="nc" id="L1088">                return super.readVolatileDouble(address);</span>
<span class="nc" id="L1089">            UNSAFE.loadFence();</span>
<span class="nc" id="L1090">            return readDouble(address);</span>
        }

        @Override
        public void writeVolatileLong(@NotNull Object object, long offset, long i64) {
<span class="nc bnc" id="L1095" title="All 2 branches missed.">            if ((offset &amp; 0x7) == 0) {</span>
<span class="nc" id="L1096">                super.writeVolatileLong(object, offset, i64);</span>
            } else {
<span class="nc" id="L1098">                writeLong(object, offset, i64);</span>
<span class="nc" id="L1099">                UNSAFE.storeFence();</span>
            }
<span class="nc" id="L1101">        }</span>

        @Override
        public void writeVolatileLong(long address, long i64) {
<span class="nc bnc" id="L1105" title="All 2 branches missed.">            if ((address &amp; 0x7) == 0) {</span>
<span class="nc" id="L1106">                super.writeVolatileLong(address, i64);</span>
            } else {
<span class="nc" id="L1108">                writeLong(address, i64);</span>
<span class="nc" id="L1109">                UNSAFE.storeFence();</span>
            }
<span class="nc" id="L1111">        }</span>

        @Override
        public void writeVolatileDouble(long address, double d) {
<span class="nc bnc" id="L1115" title="All 2 branches missed.">            if ((address &amp; 0x7) == 0)</span>
<span class="nc" id="L1116">                super.writeVolatileDouble(address, d);</span>
            else
<span class="nc" id="L1118">                writeLong(address, Double.doubleToRawLongBits(d));</span>
<span class="nc" id="L1119">        }</span>

        @Override
        public long addLong(long address, long increment) {
<span class="nc bnc" id="L1123" title="All 2 branches missed.">            if ((address &amp; 0x7) == 0)</span>
<span class="nc" id="L1124">                return super.addLong(address, increment);</span>
<span class="nc" id="L1125">            throw new IllegalArgumentException(&quot;mis-aligned&quot;);</span>
        }

        @Override
        public boolean compareAndSwapLong(@NotNull Object object, long offset, long expected, long value) {
<span class="nc bnc" id="L1130" title="All 2 branches missed.">            if ((offset &amp; 0x7) == 0)</span>
<span class="nc" id="L1131">                return super.compareAndSwapLong(object, offset, expected, value);</span>
<span class="nc" id="L1132">            throw new IllegalArgumentException(&quot;mis-aligned&quot;);</span>
        }

        @Override
        public boolean compareAndSwapLong(long address, long expected, long value) {
<span class="nc bnc" id="L1137" title="All 2 branches missed.">            if ((address &amp; 0x7) == 0)</span>
<span class="nc" id="L1138">                return super.compareAndSwapLong(address, expected, value);</span>
<span class="nc" id="L1139">            throw new IllegalArgumentException(&quot;mis-aligned&quot;);</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>